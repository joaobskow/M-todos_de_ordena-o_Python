# -*- coding: utf-8 -*-
"""trabalhoOrdenação.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OOD8GUZfvIts-kMdgp1JDB5rWU8pg4Os
"""

from typing_extensions import final
import numpy as np
import time
from numpy import random as rd

# Para testar: Lista de números em ordem aleatória.
vetor1 = np.array([8, 5, 1, 7, 9, 4, 10, 3, 6, 2])

# Para testar: Uma lista que já está ordenada.
vetor2 = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

# Para testar: Uma lista classificada em ordem decrescente.
vetor3 = np.array([10, 9, 8, 7, 6, 5, 4, 3, 2, 1])

# Para testar: Uma lista contendo elementos repetidos.
vetor4 = np.array([8, 5, 1, 7, 9, 4, 10, 3, 6, 2, 8, 5, 1])

# Para testar: Uma lista vazia.
vetor5 = np.array([])

# Para testar: Uma lista contendo apenas um elemento.
vetor6 = np.array([5])

# Para testar: Uma lista contendo um elemento repetido muitas vezes.
vetor7 = np.array([6, 9, 6, 7, 6, 5, 6, 6, 2, 6])

# Para testar: Uma lista longa.
vetor8 = rd.randint(0, 1000, 100)
vetorPeq= rd.randint(0, 1000, 1000)
vetorMed = rd.randint(0, 10000, 10000)
vetorGra = rd.randint(0, 50000, 50000)
vetorSupG = rd.randint(0, 100000, 100000)

vetor = [vetorSupG]

#adicionar as funções dentro do vetorA
vetorA = ["insertion_sort", "shell_sort", "selection_sort", "quick_sort", "merge_sort", "radix_sort"]

def bubble_sort(vetor):
  n = len(vetor)                   # Verifica tamanho do vetor.
  for i in range(n-1):             # Itera até o penúltimo item do vetor.
    for j in range(i+1, n):        # Percorre até o final do vetor, iniciando um item após i.
      if vetor[i] > vetor[j]:      # Verifica se a troca é necessária.
        vetor[i], vetor [j] = vetor[j], vetor[i]  # Realiza a troca.
  return vetor

def bubble2_sort(vetor):           # Bolha com melhor desempenho
  n = len(vetor)                   # Verifica tamanho do vetor.
  troca = True                     # Troca é uma flag que avisa quando o vetor está ordenado (melhor desempenho).
  while troca:                     # Enquanto houver troca, continua.
    troca = False                  # Considera que troca pode não ocorrer.
    for i in range(n-1):           # Percorre para o final do vetor.
      if vetor[i] > vetor[i+1]:    # Verifica se a troca é necessária.
        vetor[i], vetor[i+1] = vetor[i+1], vetor[i]  # Realiza a troca.
        troca = True               # Sinaliza que houve troca.
    n -= 1                         # Ajusta o tamanho do vetor a ser percorrido.
  return vetor

#João
# ordena dois valores, usando comparação
#Método insertion_SORT
def insertion_sort(vetor):
    trocas = 0        # contador de trocas
    comparacoes = 0    # contador de comparações

    for i in range(1, len(vetor)):     # começa a partir do segundo elemento
        aux = vetor[i]         # guarda o valor atual
        j = i - 1             # começa a comparar com o elemento anterior
        while j >= 0:         # enquanto não chegar no início do vetor
            comparacoes += 1         # conta a comparação
            if vetor[j] > aux:         # se o elemento anterior for maior que o atual
                vetor[j + 1] = vetor[j]         # move o elemento anterior para a frente
                trocas += 1         # Conta a "troca" do elemento anterior para a frente
                j -= 1         # volta uma posição
            else:         # se o elemento anterior for menor ou igual ao atual
                break         # para o loop
        if j + 1 != i:             # se o elemento não foi movido, não conta como troca
            vetor[j + 1] = aux     # insere o aux no lugar certo
            trocas += 1          # Conta a "inserção" do aux no lugar certo
    return vetor, trocas, comparacoes    # retorna o vetor ordenado e os contadores de trocas e comparações

#João
## método shell_sort
## ordena sempre de dois em dois elementos
def shell_sort(vetor):
    n = len(vetor)                          # Obtém o tamanho do vetor
    gap = n // 2                            # Inicializa o gap (distância entre elementos a serem comparados)
    trocas = 0                              # contador de trocas
    comparacoes = 0                         # contador de comparações

    while gap > 0:
        for i in range(gap, n):
            temp = vetor[i]      # Armazena o elemento atual em uma variável temporária
            j = i                # Inicializa j com o valor de i
            comparacoes += 1     #conta a comparação do elemento final
            while j >= gap and vetor[j - gap] > temp:     # Compara elementos separados pelo gap
                vetor[j] = vetor[j - gap]                 # Move o elemento para a posição correta
                j -= gap                                  # Move o elemento para a posição correta
                trocas += 1         #conta a troca do elemento final
            vetor[j] = temp         # Coloca o elemento na posição correta
            if j != i:              # se o elemento não foi movido, não conta como troca
                trocas += 1         #conta a troca do elemento final
        gap //= 2                   # Reduz o gap
    return vetor, trocas, comparacoes

#Eduardo
def selection_sort(vetor):
    trocas = 0
    comparacoes = 0

    for i in range(len(vetor)): # percorre cada posicão do vetor
        indice_menor = i # assume que o menor valor está na posição atual

        for j in range(i + 1,len(vetor)): # compara com os outros valores da frente
            comparacoes += 1
            if vetor[j] < vetor[indice_menor]:
                indice_menor = j # atualiza o indice no menor valor

        # troca os valores de posição se necessário
        if i != indice_menor:
            vetor[i], vetor[indice_menor] = vetor[indice_menor], vetor[i]
            trocas += 1

    return vetor, trocas, comparacoes

#Eduardo
def particao(vetor, inicio, final, trocas, comparacoes):
    pivo = vetor[final] # escolhe o ultimo elemento como pivo
    i = inicio - 1

    for j in range(inicio, final):
        comparacoes [0] += 1
        if vetor[j] <= pivo:
            i += 1
            vetor[i], vetor[j] = vetor[j], vetor[i]
            trocas [0] += 1

    vetor[i + 1], vetor[final] = vetor[final], vetor[i + 1]
    trocas [0] += 1
    return i + 1, trocas, comparacoes

#Eduardo
def quick_sort(vetor, inicio, final, trocas, comparacoes):
    if inicio < final:
        posicao_pivo, trocas, comparacoes= particao(vetor, inicio, final, trocas, comparacoes)

        vetor, trocas, comparacoes = quick_sort(vetor, inicio, posicao_pivo - 1, trocas, comparacoes)

        vetor, trocas, comparacoes = quick_sort(vetor, posicao_pivo + 1, final, trocas, comparacoes)

    return vetor, trocas, comparacoes

#Natanael
def merge_sort(vetor):
    if len(vetor) <= 1:
        return vetor, 0, 0  # já está ordenado

    meio = len(vetor) // 2
    esquerda, trocas_e, comp_e = merge_sort(vetor[:meio])
    direita, trocas_d, comp_d = merge_sort(vetor[meio:])

    resultado = []
    i = j = 0
    trocas = comp = 0

    while i < len(esquerda) and j < len(direita):
        comp += 1
        if esquerda[i] < direita[j]:
            resultado.append(esquerda[i])
            i += 1
        else:
            resultado.append(direita[j])
            j += 1
        trocas += 1

    # adiciona o que sobrou (sem mais comparações)
    resultado += esquerda[i:]
    resultado += direita[j:]
    trocas += len(esquerda) - i + len(direita) - j

    # soma os contadores das recursões
    total_trocas = trocas + trocas_e + trocas_d
    total_comp = comp + comp_e + comp_d

    return resultado, total_trocas, total_comp

#Natanael
def radix_sort(vetor):
    trocas = 0
    comparacoes = 0

    if len(vetor) == 0:
        return vetor, trocas, comparacoes

    # Descobre o maior número para saber quantas vezes repetir
    maior = max(vetor)
    exp = 1  # casa das unidades

    while maior // exp > 0:
        # Cria uma lista nova para armazenar os elementos ordenados por esse dígito
        novo_vetor = [0] * len(vetor)
        contagem = [0] * 10  # Para contar os dígitos de 0 a 9

        # Conta quantas vezes cada dígito aparece na posição atual
        for i in range(len(vetor)):
            indice = (vetor[i] // exp) % 10
            contagem[indice] += 1

        # Ajusta a contagem para indicar as posições corretas
        for i in range(1, 10):
            contagem[i] += contagem[i - 1]

        # Constrói o novo vetor ordenado por esse dígito (do fim para o começo)
        i = len(vetor) - 1
        while i >= 0:
            indice = (vetor[i] // exp) % 10
            comparacoes += 1
            contagem[indice] -= 1
            novo_vetor[contagem[indice]] = vetor[i]
            trocas += 1
            i -= 1

        # Atualiza o vetor original com a ordenação parcial
        for i in range(len(vetor)):
            vetor[i] = novo_vetor[i]
            trocas += 1

        # Passa para o próximo dígito
        exp *= 10
    return vetor, trocas, comparacoes

# deixar as funções acima do teste
# deixar a função teste e chamadaTeste bem abaixo
def teste(vetor, metodo):

    print(f"\nMétodo: {metodo}")

    for i in range(len(vetor)):

        inicio = time.time()

        if metodo == "insertion_sort":
          resultado, trocas, comparacoes = insertion_sort(vetor[i].copy())
          print(f"\nVetor {i+1}: ", resultado.tolist())

        elif metodo == "shell_sort":
          resultado, trocas, comparacoes = shell_sort(vetor[i].copy())
          print(f"\nVetor {i+1}: ", resultado.tolist())

        elif metodo == "selection_sort":
          resultado, trocas, comparacoes = selection_sort(vetor[i].copy())
          print(f"\nVetor {i+1}: ", resultado.tolist())

        elif metodo == "quick_sort":
            trocas = [0]
            comparacoes = [0]
            resultado, trocas, comparacoes = quick_sort(vetor[i].copy(), 0, len(vetor[i]) - 1, trocas, comparacoes)
            print(f"\nVetor {i+1}: ", resultado.tolist())

        elif metodo == "merge_sort":
            resultado, trocas, comparacoes = merge_sort(vetor[i].copy().tolist())
            print(f"\nVetor {i+1}: ", resultado)

        elif metodo == "radix_sort":
          resultado, trocas, comparacoes = radix_sort(vetor[i].copy())
          print(f"\nVetor {i+1}: ", resultado.tolist())

        fim = time.time()
        tempo_total = fim - inicio

        print(f"Trocas: {trocas} | Comparações: {comparacoes}")
        print(f"Tempo total: {tempo_total:.6f} segundos")

def chamadaTeste():
    for metodo in vetorA:
        teste(vetor, metodo)

chamadaTeste()